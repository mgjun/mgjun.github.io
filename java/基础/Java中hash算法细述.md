# Java中hash算法细述
## 哈希
**Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。**这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
散列函数的基本特征:
- 根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同
- 根据同一散列函数计算出的散列值如果相同,那么输入值不一定相同
**两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。**
常见的Hash函数有以下几种计算方式:
> 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。
> 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
> 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。
> 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
> 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
> 伪随机数法：采用一个伪随机数当作哈希函数。

关于碰撞的解决方案:
> 开放定址法：就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
> 链地址法: 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
> 再哈希法: 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
> 建立公共溢出区: 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

